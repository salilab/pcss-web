use saliweb::Test;
use Test::More tests => 1397;

use Test::Builder;
use Test::Exception;
use Test::File::Contents;

use strict;
use DBI;

BEGIN {
    use_ok('peptide');
}

my $t = new saliweb::Test('peptide');

#######################################################################################################################################################
# Testing Notes:
# Test that frontend successfully completes all three modes (application scan, application user defined, training)
# 
# General testing flow:
# 1. Make frontend object.
# 2. Create input hash that simulates what the server passes to the frontend (which itself is read from the cgi object that the frontend gets from the user).
#    Input hash will have some global values and some specific to each mode.
# 3. Call $frontend->clear()
# 4. Call $frontend->process_user_input(). The "run directory", which would normally be the job directory, is local to this test.
# 5. Input files: Parameter file is read from the testPeptideServerParameters.txt file. Other input files, including those needed to create errors 
#    for testing purposes, are in their own input directory, one for each mode.
# 6. Run all tests, both normal processing and errors. Many will compare generated files to "expected output" files; again, there is one directory containing these for each mode.
# 7. Copy generatdd files to the observed output directory, which is in the expected output directory for each mode.

# Important: 1. In all tests, need to call $frontend->clear() before calling $frontend->process_user_input($input); this resets all of the frontend's parameters.
#               Frontend will remind you of this if it thinks this is the cause of an error in its setParam() method
#            2. One thing that could break many of these is if content in modbase changes. The best solution may to make a cached table that
#               copies what this test requires from modbase and doesn't change. (Would have to update peptide.pm to query live vs cached table)
########################################################################################################################################################

my $frontend = $t->make_frontend();
my $dbh = &loadDbh();
$frontend->{'dbh'} = $dbh;

my $applicationScanTestDir = "/modbase5/home/dbarkan/peptide/test/frontend/applicationScan/";
my $applicationDefinedTestDir = "/modbase5/home/dbarkan/peptide/test/frontend/applicationDefined/";
my $trainingTestDir = "/modbase5/home/dbarkan/peptide/test/frontend/training/";

my $parameterFileName= "/netapp/sali/peptide/data/testPeptideServerParameters.txt";

#one test for each server mode 
&testServerApplicationScan($frontend, $applicationScanTestDir, $parameterFileName);
&testServerApplicationDefined($frontend, $applicationDefinedTestDir, $parameterFileName);
&testServerTraining($frontend, $trainingTestDir, $parameterFileName);


{
    my $links = $frontend->get_navigation_links();
    isa_ok($links, 'ARRAY', 'navigation links');

    like($links->[0], qr#<a href="http://modbase/top/">PCSS Home</a>#,
	 'Index link');

}



sub testServerTraining{
    my ($frontend, $testDir, $paramFileName) = @_;

    my $testInputDir = $testDir . "/input/";
    my $trainingInput = &makeTrainingInputValues($testInputDir);
    my $runDirectory = $trainingInput->{"directory"};
    my $expectedOutputDirectory = $testDir . "/expectedOutput";

    #Normal functioning
    {
	$frontend->process_user_input($trainingInput, $paramFileName);
	
	#main data files output correctly

	&compareFileLines("$expectedOutputDirectory/inputSequences.fasta", "$runDirectory/inputSequences.fasta", 1, []);
	&compareFileLines("$expectedOutputDirectory/userInputFile.txt", "$runDirectory/userInputFile.txt", 1, []);
	like(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/144\_mismatch\_negative/, "training grabbed mismatch correctly");
	&compareFileLines("$expectedOutputDirectory/parameters.txt", "$runDirectory/parameters.txt", 1, ["seqs_in_batch_count", "test_mode", "job_name"]);
	unlike(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/BARKAN/, "training mode didn't write fake accession to fasta file");
        unlike(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/O76094/, "training mode didn't write accession with no peptides to fasta file");

	#log files exist and contain proper stats
	my $userLogString = &convertFileToString("$runDirectory/user.log");
	like($userLogString, qr/peptide server in training mode/, "training user log content, server mode listed");

	like($userLogString, qr/accession BARKAN was not/, "training user log content, didn't find fake accession");
	like($userLogString, qr/Start Position\: 145/, "training user log content, mismatch noted");
	like($userLogString, qr/\[overrun \-\- 119\]/, "training user log content, overshot noted");

	like($userLogString, qr/None of the provided peptides for Uniprot Accession O76094/, "training user log content, no peptides found for a protein");

	like($userLogString, qr/Accessions found in modbase: 54/, "training user log content, peptides found vs missed 1");  
	like($userLogString, qr/Accessions not found in modbase \(noted above in this log file\): 2/, "training user log content, peptides found vs missed 2");  
	like($userLogString, qr/accessions read from input file: 56/, "training user log content, peptides found vs missed 3");  

	like($userLogString, qr/peptides supplied in modbase proteins: 521/, "training user log content, statistics 1");
	like($userLogString, qr/Positives: 52/, "training user log content, statistics 2");
	like($userLogString, qr/Negatives: 469/, "training user log content, statistics 3");

	like($userLogString, qr/matching modbase protein sequences: 446/, "training user log content, statistics 4");
	like($userLogString, qr/Positives: 51/, "training user log content, statistics 5");
	like($userLogString, qr/Negatives: 395/, "training user log content, statistics 6");

	like($userLogString, qr/containing these mismatched peptides: 3/, "training user log content, statistics 7");
	like($userLogString, qr/the sequence: 75/, "training user log content, statistics 8");

	my $frameworkLogString = &convertFileToString("$runDirectory/framework.log");
	like ($frameworkLogString, qr/read from input file: 56/, "training framework log content, total accession statistics");
	like ($frameworkLogString, qr/to make sure that/, "training framework log content, framework specific message");

	&testAndPostprocessFiles($runDirectory, $expectedOutputDirectory);
    }

    #Validate there are more negatives in the training set than positives, and positives test set > 1
    {
	$frontend->clear();
	my $badTrainingSetCountFile = $testInputDir . "/trainingSetCountValidationFileInput";
	
	my $fh = FileHandle->new("<" . $badTrainingSetCountFile) || die "could not open $badTrainingSetCountFile\n";
	$trainingInput->{'training_file'} = $fh;
	#this test is cleverly designed to initially have the appropriate ratio, but goes bad after some of the negative peptides don't pass validation filters
	throws_ok { $frontend->process_user_input($trainingInput, $paramFileName) } qr/Please change the number of negative peptides/, 'exception if more training set positive than negatives';

	$frontend->clear();
	$badTrainingSetCountFile = $testInputDir . "/trainingSetPositiveValidationInput";
	
	$fh = FileHandle->new("<" . $badTrainingSetCountFile) || die "could not open $badTrainingSetCountFile\n";
	$trainingInput->{'training_file'} = $fh;
	throws_ok { $frontend->process_user_input($trainingInput, $paramFileName) } qr/ensure that there is at least one peptide/, 'exception if not at least one positive in test set';
    }

    #Ensure failure if error handling set to "I" but all seqs are mismatches or not found.
    {
	$frontend->clear();
	my $trainingFakeSeqFile =  $testInputDir . "/trainingFakeSeqFile";
	my $fakeSeqFileFh = FileHandle->new("<" . $trainingFakeSeqFile) || die "could not open $trainingFakeSeqFile";
	$trainingInput->{"training_file"} = $fakeSeqFileFh;
	throws_ok { $frontend->process_user_input($trainingInput, $paramFileName) } qr/due to having no input/, 'exception if no accession is found in training mode';
    }


    #Valid peptide file -- all exceptions in readAndValidatePeptideFile()
    {
	
	my $badPeptideFileToErrors = &getBadPeptideFileToErrorsMap();
	$badPeptideFileToErrors->{invalidClassification} = "classification for a peptide";   #extra error for training mode

	my $peptideFileErrorDirectory = $testInputDir . "/peptideFileErrors";
	foreach my $badPeptideFile (keys %$badPeptideFileToErrors){

	    my $peptideFh = FileHandle->new("<" . $peptideFileErrorDirectory . "/" . $badPeptideFile) || die "could not open bad peptide file $badPeptideFile";
	    my $exceptionMessage = $badPeptideFileToErrors->{$badPeptideFile};
#	    throws_ok {$frontend->readAndValidatePeptideFile($peptideFh)}
#	    qr /$exceptionMessage/, "exception if training mode peptide file $badPeptideFile formatted incorrectly";
	}
	my $missingPeptideFh;

	throws_ok {$frontend->readAndValidatePeptideFile($missingPeptideFh)}
	qr /No peptide file has been/, "exception if training peptide file not provided";
    }

    #Training specific user-input values
    {
	throws_ok {$frontend->validateJackknifeFraction(.51)}
	qr /Please set the Jackknife Fraction/, "exception if user-specified jackknife fraction > .5";
   
	throws_ok {$frontend->validateJackknifeFraction(0)}
	qr /to a value greater than/, "exception if user-specified jackknife fraction == 0";

	throws_ok{$frontend->validateTrainingIterations(1001)}
	qr /Please set the Training Iterations/, "exception if user-specified training iterations > 1000";
    }

    #Simple global options -- think it's ok if these are only tested in training mode
    {
	throws_ok{$frontend->validateJobName("")}
	qr /Please provide a name for your job/, "exception if user doesn't specify job name";
		  
	#TODO -- when TEST::Files module available, make sure sequences directory is created
    }
    
    $frontend->clear();


}


sub testServerApplicationDefined{
    my ($frontend, $testDir, $paramFileName) = @_;
    
    

    my $testInputDir = $testDir . "/input/";
    my $applicationDefinedInput = &makeApplicationDefinedInput($testInputDir);
    my $runDirectory = $applicationDefinedInput->{"directory"};
    my $expectedOutputDirectory = $testDir . "/expectedOutput";

    #Normal functioning
    {
	$frontend->process_user_input($applicationDefinedInput, $paramFileName);

	#Main data files were output correctly
	
	&compareFileLines("$expectedOutputDirectory/inputSequences.fasta", "$runDirectory/inputSequences.fasta", 1, []);
	&compareFileLines("$expectedOutputDirectory/userInputFile.txt", "$runDirectory/userInputFile.txt", 1, []);
	like(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/850\_mismatch\_Application/, "application defined wrote mismatch to fasta file");
	#TODO - after Test::File loaded	compare_ok("$expectedOutputDirecory/inputSequences.fasta", "$runDirectory/inputSequences.fasta", "application scan fasta sequences");    
	&compareFileLines("$expectedOutputDirectory/parameters.txt", "$runDirectory/parameters.txt", 1, ["seqs_in_batch_count", "test_mode", "job_name"]);
	&compareFileLines("$expectedOutputDirectory/mismatches.fasta", "$runDirectory/mismatches.fasta", 1, []);
	

	#missing accession not written to fasta file
	unlike(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/BARKAN/, "application defined didn't write fake acccession to fasta file");
        unlike(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/O76094/, "application defined mode didn't write accession with no peptides to fasta file");  

	#User log has key pieces of information written and stats
	#TODO -- user log exists (after Test::File loaded)
	
	my $userLogString = &convertFileToString("$runDirectory/user.log");

	like($userLogString, qr/BARKAN was not found/, "application defined user log content, didn't find fake accession");


	like($userLogString, qr/\[overrun \-\- 119\]/, "application defined user log content, first overshot");
	like($userLogString, qr/\[overrun \-\- 857\]/, "application defined user log content, second overshot");
	like($userLogString, qr/Start Position\: 420/, "application defined user log content, mismatch");
	like($userLogString, qr/provided peptides for Uniprot Accession Q05CV4/, "application defined user log content, no peptides found for a protein");

	like($userLogString, qr/Number of accessions read from input file: 20/, "application defined user log content, total accessions");
	like($userLogString, qr/Accessions found in modbase: 19/, "application defined user log content, accessions found");
	like($userLogString, qr/not found in modbase \(noted above in this log file\): 1/, "application defined user log content, accessions missed");

	like($userLogString, qr/peptides supplied in modbase proteins: 25/, "application defined user log content, statistics 1");
	like($userLogString, qr/matching modbase protein sequences: 22/, "application defined user log content, statistics 2");

	like($userLogString, qr/containing these mismatched peptides: 3/, "application defined user log content, statistics 3");
	like($userLogString, qr/user-supplied position: 3/, "application defined user log content, statistics 4");

	#framework log has key pieces of info written
	#TODO -- framework log exists
	my $frameworkLogString = &convertFileToString("$runDirectory/framework.log");
	like ($frameworkLogString, qr/20 provided/, "application defined framework log content, total accessions");
	like ($frameworkLogString, qr/BARKAN was not found/, "application defined framework log content, didn't find fake accession");
	like($frameworkLogString, qr/1 proteins had only mismatches/, "application defined framework log content, total number with no peptides found");
	&testAndPostprocessFiles($runDirectory, $expectedOutputDirectory);
    }


    #Valid peptide file -- all exceptions in readAndValidatePeptideFile()
    {
	my $badPeptideFileToErrors = &getBadPeptideFileToErrorsMap();

	my $peptideFileErrorDirectory = $testInputDir . "/peptideFileErrors";
	foreach my $badPeptideFile (keys %$badPeptideFileToErrors){

	    my $peptideFh = FileHandle->new("<" . $peptideFileErrorDirectory . "/" . $badPeptideFile) || die "could not open bad peptide file $badPeptideFile";
	    my $exceptionMessage = $badPeptideFileToErrors->{$badPeptideFile};
#	    throws_ok {$frontend->readAndValidatePeptideFile($peptideFh)}
#	    qr /$exceptionMessage/, "exception if application defined peptide file $badPeptideFile formatted incorrectly";
	}

	my $missingPeptideFh;

	throws_ok {$frontend->readAndValidatePeptideFile($missingPeptideFh)}
	qr /No peptide file has been/, "exception if application defined peptide file not provided";
    }
    
    #Failure if error handling set to "I" but all seqs are mismatches or no accessions found.
    {
	$frontend->clear();
	
	my $applicationFakeSeqFile =  $testInputDir . "/applicationFakeSeqFile";
	my $fakeSeqFileFh = FileHandle->new("<" . $applicationFakeSeqFile) || die "could not open $applicationFakeSeqFile";
	$applicationDefinedInput->{"application_file"} = $fakeSeqFileFh;
	throws_ok { $frontend->process_user_input($applicationDefinedInput, $paramFileName) } qr/due to having no input/, 'exception if no accession is found in application defined mode';
    }

    {
	$frontend->clear();
	my $applicationAllMismatchesFile = $testInputDir . "/testApplicationDefinedOnlyMismatches";
	my $applicationMismatchesFh = FileHandle->new("<" . $applicationAllMismatchesFile) || die "could not open $applicationAllMismatchesFile";
	$applicationDefinedInput->{"application_file"} = $applicationMismatchesFh;
	throws_ok { $frontend->process_user_input($applicationDefinedInput, $paramFileName) }  qr/Make sure your numbering system/, 'exception if all provided user-defined peptides had mismatches';
    }

    
    #Failure if error handling set to "Q" and mismatches or sequences not found. This applies to training too, but error handling is global option so should be fine.
    {
	$frontend->clear();
	
	my $applicationFakeSeqFile =  $testInputDir . "/applicationFakeSeqFile";
	my $fakeSeqFileFh = FileHandle->new("<" . $applicationFakeSeqFile) || die "could not open $applicationFakeSeqFile";
	$applicationDefinedInput->{"application_file"} = $fakeSeqFileFh;
	$applicationDefinedInput->{"error_handling"} = "Q";
	throws_ok { $frontend->process_user_input($applicationDefinedInput, $paramFileName) } qr/error handling option was set to/, 'exception if error handling is "Q" and accession not found';

	$frontend->clear();

	my $applicationFakeMismatchFile =  $testInputDir . "/applicationFakeMismatchFile";
	my $fakeMismatchFileFh = FileHandle->new("<" . $applicationFakeMismatchFile) || die "could not open $applicationFakeMismatchFile";
	$applicationDefinedInput->{"application_file"} = $fakeMismatchFileFh;

	throws_ok { $frontend->process_user_input($applicationDefinedInput, $paramFileName) } qr/error handling option was set to/, 'exception if error handling is "Q" and get sequence mismatch';
    }

    $frontend->clear();

}
	

sub testServerApplicationScan{
    my ($frontend, $testDir, $paramFileName) = @_;

    my $testInputDir = $testDir . "/input/";
    my $applicationScanInput = &makeApplicationScanInput($testInputDir);
    my $runDirectory = $applicationScanInput->{"directory"};
    my $expectedOutputDirectory = $testDir . "/expectedOutput";
    #Normal functioning
    {
	$frontend->process_user_input($applicationScanInput, $paramFileName);
	
	#Main data files were output correctly
	&compareFileLines("$expectedOutputDirectory/inputSequences.fasta", "$runDirectory/inputSequences.fasta", 1, []);
	&compareFileLines("$expectedOutputDirectory/userInputFile.txt", "$runDirectory/userInputFile.txt", 1, []);
	file_contents_identical("$expectedOutputDirectory/inputSequences.fasta", "$runDirectory/inputSequences.fasta", "application scan fasta sequences");    
	&compareFileLines("$expectedOutputDirectory/parameters.txt", "$runDirectory/parameters.txt", 1, ["seqs_in_batch_count", "test_mode", "job_name"]);
	&compareFileLines("$expectedOutputDirectory/peptideRulesFile", "$runDirectory/peptideRulesFile", 1, []);
  	
	#missing accession not written to fasta file
	unlike(&convertFileToString("$expectedOutputDirectory/inputSequences.fasta"), qr/BARKAN/, "appliction scan does not write fake accession to fasta file");

	#User log has key pieces of information written
	#TODO -- user log exists (after Test::File loaded)
	my $userLogString = &convertFileToString("$runDirectory/user.log");
	like($userLogString, qr/BARKAN was not found/, "application scan user log content, didn't find fake accessions");

	like($userLogString, qr/read from input file: 103/, "application scan user log content, total accessions");
	like($userLogString, qr/accessions found in modbase: 102/, "application scan user log content, peptides found vs missed");
	like($userLogString, qr/missed \(noted above in this log file\): 1/, "application scan user log content, peptides found vs missed");
	
	#Framework log has key pieces of information written and stats
	my $frameworkLogString = &convertFileToString("$runDirectory/framework.log");
	like($frameworkLogString, qr/read from input file: 103/, "application scan framework log content, total accessions");
	like($frameworkLogString, qr/accessions found in modbase: 102/, "application scan framework log content, peptides found vs missed");
	like($frameworkLogString, qr/missed \(noted above in this log file\): 1/, "application scan framework log content, peptides found vs missed");
	like($frameworkLogString, qr/BARKAN was not found/, "application scan framework log content, didn't find fake accessions");


	&testAndPostprocessFiles($runDirectory, $expectedOutputDirectory);
    }

    #Valid application file -- all exceptions in readAndValidateApplicationFile()
#    {
# 	my $badAppFileToErrors = &getBadAppFileToErrorsMap();

# 	my $appFileErrorDirectory = $testInputDir . "/applicationFileErrors";
# 	foreach my $badAppFile (keys %$badAppFileToErrors){
# 	    my $appFh = FileHandle->new("<" . $appFileErrorDirectory . "/" . $badAppFile) || die "could not open bad application file $badAppFile";
# 	    my $exceptionMessage = $badAppFileToErrors->{$badAppFile};
# 	    throws_ok {$frontend->readAndValidateApplicationFile($appFh)}
# 	    qr /$exceptionMessage/, "exception if application scan peptide file $badAppFile formatted incorrectly";
# 	}

# 	my $missingApplicationFh;

# 	throws_ok {$frontend->readAndValidateApplicationFile($missingApplicationFh)}
# 	qr /No application target file/,  "exception if application scan file not provided";
#    }

    #proper rules file output if user didn't specify anything (should be one line that says "### No rules file specified")
    {
	$frontend->clear();
	my $applicationScanInput = &makeApplicationScanInput($testInputDir);  #reload fh
	$applicationScanInput->{"rules_file"} = 0;
	$frontend->process_user_input($applicationScanInput, $paramFileName);
	like(&convertFileToString("$runDirectory/peptideRulesFile"), qr/\#\#\# No rules file specified/, "user specified no rules has correct output");
    }
	
    #Fail if none of the provided sequences found in modbase at all
    {
	$frontend->clear();
	
	my $applicationNoSeqsFoundFile = $testInputDir . "/noSeqsFoundInput";
	my $noSeqsFoundFh = FileHandle->new("<" . $applicationNoSeqsFoundFile) || die "could not open $applicationNoSeqsFoundFile";
	$applicationScanInput->{"application_file"} = $noSeqsFoundFh;
	throws_ok { $frontend->process_user_input($applicationScanInput, $paramFileName) } 
	qr /Although the error handling option/, 'exception if no user supplied sequences found in modbase at all in application scan mode';
    }
   
    #Valid rules file -- all exceptions in readAndValidateRulesFile()
    {
	my $badRulesFileToErrors = &getBadRulesFileToErrorsMap();

	my $rulesFileErrorDirectory = $testInputDir . "/rulesFileErrors";
	foreach my $badRulesFile (keys %$badRulesFileToErrors){

	    my $rulesFh = FileHandle->new("<" . $rulesFileErrorDirectory . "/" . $badRulesFile) || die "could not open bad rules file $badRulesFile";
	    my $exceptionMessage = $badRulesFileToErrors->{$badRulesFile};
	    throws_ok {$frontend->readAndValidateRulesFile($rulesFh, 8)}
	    qr /$exceptionMessage/, "exception if application scan peptide file $badRulesFile formatted incorrectly";
	}
    }
    $frontend->clear();
    
}


#Skip list are lines that might be different in test vs production mode, so don't compare these
sub compareFileLines{

    my ($firstFile, $secondFile, $sortFiles, $skipList) = @_;

    if ($sortFiles){
	my $firstSortedFile = $firstFile . "_sorted";
	my $firstSortCmd = "sort $firstFile > $firstSortedFile";
	system($firstSortCmd);

	my $secondSortedFile = $secondFile . "_sorted";
	my $secondSortCmd = "sort $secondFile > $secondSortedFile";
	system($secondSortCmd);

	$firstFile = $firstSortedFile;
	$secondFile = $secondSortedFile;
    }
    my $firstFileLines = &loadFile($firstFile, $skipList);
    my $secondFileLines = &loadFile($secondFile, $skipList);

    my $secondLineCounter = 0;
    
    foreach my $firstLine (@$firstFileLines){
	my $secondLine = $secondFileLines->[$secondLineCounter];
#	print STDERR "comparing lines $firstLine and $second
	is($firstLine, $secondLine, "lines in $firstFile and $secondFile match");
	$secondLineCounter++;
    }
    

    
}

sub loadFile{
    my ($fileName, $skipList) = @_;
    my @fileLines;
    my $fh = FileHandle->new("<" . $fileName) || die "could not open file $fileName for loading lines\n";
    while (<$fh>){
	chomp;
	my $line = $_;
	next if ($line =~ /^\s*$/);
	my $skipLine = 0;
	foreach my $skip (@$skipList){
	    if ($line =~ /$skip/){
		$skipLine = 1;
	    }
	}
	next if ($skipLine == 1);
	push (@fileLines, $line);
    }
    return \@fileLines;

}


sub convertSortedFileToString{

    my ($directory, $fileName) = @_;
    my $fullFileName = $directory . "/" . $fileName;
    my $fullSortedFileName = $directory . "/" . $fileName . "_sorted";
    
    my $sortCmd = "sort $fullFileName > $fullSortedFileName";
    system ($sortCmd);

    my $sortedString = &convertFileToString($fullSortedFileName);

    my $deleteCmd = "rm $fullSortedFileName";
    system($deleteCmd);
    return $sortedString;
}


sub convertFileToString{
    my ($fileName) = @_;
    my $fh = FileHandle->new("<" . $fileName) || die "could not open $fileName\n";
    my $string = "";
    while (<$fh>){
	chomp;
	$string .= $_;
    }
    return $string;
}


sub makeApplicationDefinedInput{
    my ($testInputDir) = @_;
    my $input;

    $input = &makeGlobalInputValues($input);
    $input = &makeApplicationInputValues($input, $testInputDir);

    $input->{'application_specification'} = 'D';

    return $input;
}


sub makeApplicationScanInput{
    my ($testInputDir) = @_;
    my $input;

    $input = &makeGlobalInputValues($input);
    $input = &makeApplicationInputValues($input, $testInputDir);

    my $rulesFileName = "$testInputDir/testRulesFileInput";
    my $rulesFh = FileHandle->new("<" . $rulesFileName) || die "could not open $rulesFileName\n";

    $input->{'rules_file'} = $rulesFh;
    $input->{'application_specification'} = 'S';

    return $input;
}



sub makeApplicationInputValues{
    my ($input, $testInputDir) = @_;

    #add application input values (global ones; independent of scan mode vs defined mode)
    my $svmModel = "grb"; 
    my $applicationFileName = "$testInputDir/testApplicationFileInput";
    my $applicationFh = FileHandle->new("<" . $applicationFileName) || die "could not open $applicationFileName\n";
    
    $input->{'svm_model'} = $svmModel;
    $input->{'application_file'} = $applicationFh;
    $input->{'server_mode'} = "application";
    return $input;

}

sub makeTrainingInputValues{
    my ($testInputDir) = @_;

    my $input;
    $input = &makeGlobalInputValues($input);
    $input->{'server_mode'} = "training";
    $input->{'jackknife_fraction'} = "0.1";  #have to make this a string, otherwise converts to 0.1 which messes up the parameter comparison.  Might be an issue later.
    $input->{'training_iterations'} = 10;
    
    my $trainingFileName = "$testInputDir/testTrainingFileInput";
    my $trainingFh = FileHandle->new("<" . $trainingFileName) || die "could not open $trainingFileName\n";
    $input->{'training_file'} = $trainingFh;

    return $input;

}

sub getBadAppFileToErrorsMap{

    my $badAppFileToErrors;
    $badAppFileToErrors->{multipleEntries} = "more than one entry";
    $badAppFileToErrors->{noValidEntries} = "did not contain any";
    return $badAppFileToErrors;

}

sub getBadPeptideFileToErrorsMap{
    my $badPeptideFileToErrors;
#    $badPeptideFileToErrors->{differentLength} = "must be the same length";
    $badPeptideFileToErrors->{invalidResidue} = "consist only of the 20 standard amino"; 
    $badPeptideFileToErrors->{missingColumn} = "each line must be of the format";
    $badPeptideFileToErrors->{noEntries} = "did not contain any entries";
    $badPeptideFileToErrors->{noNumber} = "start position must be a number";
    $badPeptideFileToErrors->{numberInSequence} = "must consist of valid one";
    return $badPeptideFileToErrors;
    
}

sub getBadRulesFileToErrorsMap{
    my $badRulesFileToErrors;

    $badRulesFileToErrors->{allResiduesExcluded} = "cannot exclude all 20 residues";
    $badRulesFileToErrors->{samePositionTwice} = "found in two different places";
    $badRulesFileToErrors->{outOfBounds} = "score peptides of the same length";
    $badRulesFileToErrors->{missingNumber} = "begins with a number";
    $badRulesFileToErrors->{badResidue} = "20 standard amino acids";
    $badRulesFileToErrors->{spaceMissing} = "designated by one letter";


    return $badRulesFileToErrors;

}

sub testAndPostprocessFiles{

    my ($runDirectory, $expectedOutputDirectory) = @_;
    my @fileNames =  ("user.log", "framework.log", "parameters.txt",  "inputSequences.fasta", "peptideRulesFile", "sequenceBatches", "userInputFile.txt", "mismatches.fasta");
    &checkFilesExist($runDirectory, @fileNames);
    push (@fileNames, "parameters.txt_sorted");
    push (@fileNames, "inputSequences.fasta_sorted");
    
    &copyFiles($runDirectory, "$expectedOutputDirectory/observedOutput", @fileNames);
}

sub checkFilesExist{
    my ($runDirectory, @fileNames) = @_;
    foreach my $file (@fileNames){
	ok(-e "$runDirectory/$file",  "file $file successfully written");
    }
}


sub copyFiles{
    my ($sourceDir, $destinationDir, @fileList) = @_;
    my $cpCmd = "cp -r ";
    foreach my $file (@fileList){
	$cpCmd .= "$sourceDir/$file ";
    }
    $cpCmd .= $destinationDir;
    system($cpCmd);
    
}


sub makeGlobalInputValues{

    my ($input) = @_;

    my $email = 'dbarkan@salilab.org';                       $input->{'email'} = $email;
    my $name = 'peptide_server_test';                        $input->{'name'} = $name; 
    my $errorHandling = 'I';                                 $input->{'error_handling'} = $errorHandling;
    my $bestModel = 'nativeOverlap';                         $input->{'best_model'} = $bestModel; 
    my $directory = 
	"/modbase5/home/dbarkan/peptide/test/frontend/run";  $input->{'directory'} = $directory;
    
    return $input;
}


sub loadDbh{
    my $dbString = "DBI:mysql:database=modbase_synonyms:hostname=modbase";
    my $username = "modbase";
    my $password = "***REMOVED***";
    my $dbh = DBI->connect( $dbString, $username, $password, {RaiseError => 1});
    return $dbh;
}



